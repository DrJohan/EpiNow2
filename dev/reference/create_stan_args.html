<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Create a List of Stan Arguments — create_stan_args • EpiNow2</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>


<!-- docsearch -->
<script src="../docsearch.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous" />
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>



<meta property="og:title" content="Create a List of Stan Arguments — create_stan_args" />
<meta property="og:description" content="Generates a list of arguments as required by rstan::sampling (when method = &quot;exact) or
rstan::vb (when method = &quot;approximate). See create_stan_args() for the defaults and the relevant rstan
functions for additional options." />
<meta property="og:image" content="epiforecasts.io/EpiNow2/reference/figures/unnamed-chunk-13-1.png" />
<meta property="og:image:alt" content="Example estimates produced by EpiNow2 of the reproduction number, cases by date of infection and cases by date of report" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content="@seabbs" />
<meta name="twitter:site" content="@cmmid_lshtm" />


<meta name="robots" content="noindex">

<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EpiNow2</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.3.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../reference/index.html">
    <span class="fa fa-file-code-o"></span>
     
    Functions
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/epiforecasts/EpiNow2">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
      
      <form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
        </div>
      </form>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Create a List of Stan Arguments</h1>
    
    <div class="hidden name"><code>create_stan_args.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Generates a list of arguments as required by <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html'>rstan::sampling</a></code> (when <code>method = "exact</code>) or
<code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-vb.html'>rstan::vb</a></code> (when <code>method = "approximate</code>). See <code>create_stan_args()</code> for the defaults and the relevant <code>rstan</code>
functions for additional options.</p>
    </div>

    <pre class="usage"><span class='fu'>create_stan_args</span><span class='op'>(</span>
  <span class='va'>model</span>,
  data <span class='op'>=</span> <span class='cn'>NULL</span>,
  init <span class='op'>=</span> <span class='st'>"random"</span>,
  samples <span class='op'>=</span> <span class='fl'>1000</span>,
  stan_args <span class='op'>=</span> <span class='cn'>NULL</span>,
  method <span class='op'>=</span> <span class='st'>"exact"</span>,
  verbose <span class='op'>=</span> <span class='cn'>FALSE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>model</th>
      <td><p>A stan model object, defaults to packaged model if not supplied.</p></td>
    </tr>
    <tr>
      <th>data</th>
      <td><p>A list of stan data as created by <code>create_stan_data</code></p></td>
    </tr>
    <tr>
      <th>init</th>
      <td><p>Initial conditions passed to <code>rstan</code>. Defaults to "random" but can also be a function (
as supplied by <code>create_intitial_conditions</code>).</p></td>
    </tr>
    <tr>
      <th>samples</th>
      <td><p>Numeric, defaults to 1000. The overall number of posterior samples to return (Note: not the
number of samples per chain as is the default in stan).</p></td>
    </tr>
    <tr>
      <th>stan_args</th>
      <td><p>A list of stan arguments to be passed to <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html'>rstan::sampling</a></code> or <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-vb.html'>rstan::vb</a></code> (when using the "exact"
or "approximate" method). For <code>method = approximate</code> an additional argument <code>trials</code> indicates the number of attempts to make
using variational inference before returning an error (as stochastic failure is possible). The default for this is 5.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>A character string defaults to "exact". Also accepts "approximate". Indicates the fitting method to be used
this can either be "exact" (NUTs sampling) or "approximate" (variational inference). The exact approach returns samples
from the posterior whilst the approximate method returns approximate samples. The approximate method is likely to return results
several order of magnitudes faster than the exact method.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>Logical, defaults to <code>FALSE</code>. Should verbose progress messages be returned.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A list of stan arguments</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>
<span class='co'># default settings</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt;= 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt;= 0 ? 1e-5 : beta;
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt; 
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt; 
#&gt; // convolve latent infections to reported (but still unobserved) cases
#&gt; vector convolve_to_report(vector infections, 
#&gt;                           real[] delay_mean, 
#&gt;                           real[] delay_sd,
#&gt;                           int[] max_delay,
#&gt;                           int seeding_time) {
#&gt;   int t = num_elements(infections);
#&gt;   vector[t - seeding_time] reports;
#&gt;   vector[t] reports_hold = infections;
#&gt;   int delays = num_elements(delay_mean);
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;       for (j in 1:(max_delay[s])) {
#&gt;         rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;       }
#&gt;       reports_hold = convolve(reports_hold, rev_delay);
#&gt;     }
#&gt;     reports = reports_hold[(seeding_time + 1):t];
#&gt;   }else{
#&gt;     reports = infections[(seeding_time + 1):t];
#&gt;   }
#&gt;   return(reports);
#&gt; }
#&gt; 
#&gt; void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, 
#&gt;                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){
#&gt;     int delays = num_elements(delay_mean);
#&gt;     if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;
#&gt;     }
#&gt;   }
#&gt; }
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 
#&gt; 
#&gt; int setup_noise(int ot_h, int t, int horizon, int estimate_r, 
#&gt;                 int stationary, int future_fixed, int fixed_from) {
#&gt;   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;
#&gt;   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time; 
#&gt;   return(noise_terms);
#&gt; }
#&gt; 
#&gt; 
#&gt; matrix setup_gp(int M, real L, int dimension) {
#&gt;   vector[dimension] time;
#&gt;   matrix[dimension, M] PHI;
#&gt;   for (s in 1:dimension) {
#&gt;     time[s] = s;
#&gt;   }
#&gt;   for (m in 1:M){ 
#&gt;     PHI[,m] = phi_SE(L, m, time); 
#&gt;   }
#&gt;   return(PHI);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector update_gp(matrix PHI, int M, real L, real alpha, real rho, vector eta) {
#&gt;   vector[M] diagSPD;    // spectral density
#&gt;   vector[M] SPD_eta;    // spectral density * noise
#&gt;   int noise_terms = rows(PHI);
#&gt;   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);
#&gt;   // GP in noise - spectral densities
#&gt;   for(m in 1:M){ 
#&gt;     diagSPD[m] =  sqrt(spd_SE(alpha, rho, sqrt(lambda(L, m)))); 
#&gt;   }
#&gt;   SPD_eta = diagSPD .* eta;
#&gt;   noise = noise + PHI[,] * SPD_eta;
#&gt;   return(noise);
#&gt; }
#&gt; 
#&gt; void gaussian_process_lp(real[] rho, real[] alpha, vector eta,
#&gt;                          real ls_alpha, real ls_beta, real alpha_sd) {
#&gt;   rho ~ inv_gamma(ls_alpha, ls_beta);
#&gt;   alpha ~ normal(0, alpha_sd);
#&gt;   eta ~ std_normal();
#&gt; }
#&gt; 
#&gt; 
#&gt; 
#&gt; real update_breakpoints(real input_R, real[] bp_effects,
#&gt;                         int bp_index, int at_bp,
#&gt;                         int stationary) {
#&gt;   real R = input_R;
#&gt;   if (stationary) {
#&gt;     if (bp_index &gt; 0) {
#&gt;       R += sum(bp_effects[1:bp_index]);
#&gt;       }
#&gt;   }else{
#&gt;     if (at_bp) {
#&gt;       R += bp_effects[bp_index];
#&gt;     }
#&gt;   }               
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; real update_R(vector R, vector noise, int noise_terms,
#&gt;               int index, int stationary) {
#&gt;   real cR = R[index];
#&gt;   if (noise_terms &gt; 0) {
#&gt;     if (stationary){
#&gt;       if (index &lt;= noise_terms) {
#&gt;         cR += noise[index];
#&gt;       }else{
#&gt;         if (index &gt; 1) {
#&gt;            cR = R[index - 1];
#&gt;         }
#&gt;       }
#&gt;     }else{
#&gt;       if (index &lt;= (noise_terms + 1)) {
#&gt;         cR = R[index - 1] + noise[index - 1];
#&gt;       }else{
#&gt;         cR = R[index - 1];
#&gt;       }
#&gt;     }
#&gt;   }
#&gt;   return(cR);
#&gt; }
#&gt; 
#&gt; vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,
#&gt;                  real[] bp_effects, int stationary) {
#&gt;   // define control parameters
#&gt;   int noise_terms = num_elements(noise);
#&gt;   int i_stationary = noise_terms &gt; 0 ? stationary : 1;
#&gt;   int t = num_elements(input_R);
#&gt;   int bp_n = num_elements(bp_effects);
#&gt;   int bp_in = 0;
#&gt;   int at_bp = 0;
#&gt;   int index;
#&gt;   vector[t] R;
#&gt;   // initialise Rt
#&gt;   if (i_stationary) {
#&gt;     R = rep_vector(log_R, t);
#&gt;     index = 1;
#&gt;   }else{
#&gt;     R[1] = log_R;
#&gt;     index = 2;
#&gt;   }
#&gt;   // iteratively update Rt
#&gt;   for (s in index:t) {
#&gt;     R[s] = update_R(R, noise, noise_terms, s, i_stationary);
#&gt;     if (bp_n &gt; 0) {
#&gt;       at_bp = bps[s];
#&gt;       bp_in += at_bp;
#&gt;       R[s] = update_breakpoints(R[s], bp_effects, bp_in, at_bp, i_stationary);
#&gt;     }
#&gt;   }
#&gt;   // convert to correct scale
#&gt;   R = exp(R);
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; real update_infectiousness(vector infections, vector gt_pmf,
#&gt;                            int seeding_time, int max_gt, int index){
#&gt;   int inf_start = max(1, (index + seeding_time - max_gt));
#&gt;   int inf_end = (index + seeding_time - 1);
#&gt;   int pmf_accessed = min(max_gt, index + seeding_time - 1);
#&gt;   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));
#&gt;   return(new_inf);
#&gt; }
#&gt; 
#&gt; vector generate_infections(vector R, int seeding_time, real[] gt_mean, 
#&gt;                            real[] gt_sd, int max_gt, vector shifted_cases,
#&gt;                            vector initial_infections) {
#&gt;   int rt = num_elements(R);
#&gt;   int t = rt + seeding_time;
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   vector[max_gt] gt_pmf;              // reversed generation time pdf
#&gt;   vector[rt] infectiousness = rep_vector(1e-5, rt);  // infections over time
#&gt;   
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] = discretised_gamma_pmf(max_gt - j + 1, gt_mean[1], gt_sd[1], max_gt);
#&gt;   }
#&gt;   // estimate initial infections not using Rt
#&gt;   infections[1:seeding_time] = infections[1:seeding_time] + shifted_cases[1:seeding_time] .* initial_infections;
#&gt;   
#&gt;   for (s in 1:rt) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     infections[s + seeding_time] += R[s] * infectiousness[s];
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector deconvolve_infections(vector shifted_cases, vector noise, int fixed) {
#&gt;   int t = num_elements(shifted_cases);
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   if(!fixed) {
#&gt;     infections = infections + shifted_cases .* exp(noise);
#&gt;   }else{
#&gt;     infections = infections + shifted_cases;
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, 
#&gt;                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {
#&gt;     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;
#&gt;     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;
#&gt; }
#&gt; 
#&gt; vector calculate_Rt(vector infections, int seeding_time,
#&gt;                     real gt_mean, real gt_sd, int max_gt) {
#&gt;   vector[max_gt] gt_pmf;  
#&gt;   int t = num_elements(infections);
#&gt;   int ot = t - seeding_time;
#&gt;   vector[ot] R;
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot); 
#&gt;   // calculate PMF of the generation time
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] =  discretised_gamma_pmf(max_gt - j + 1, gt_mean, gt_sd, max_gt);
#&gt;   }
#&gt;   // calculate Rt using Cori et al. approach
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     R[s] = infections[s + seeding_time] / infectiousness[s];
#&gt;   }
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {
#&gt;   int t = num_elements(reports);
#&gt;   // scale day of week effect
#&gt;   vector[7] scaled_effect = 7 * effect;
#&gt;   vector[t] scaled_reports;
#&gt;   for (s in 1:t) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];
#&gt;    }
#&gt;   return(scaled_reports);
#&gt; }
#&gt; 
#&gt;    
#&gt; void report_lp(int[] cases, vector reports, 
#&gt;                real[] rep_phi, int phi_prior,
#&gt;                int model_type, int horizon,
#&gt;                int weight) {
#&gt;   int t = num_elements(reports) - horizon;
#&gt;   if (model_type) {
#&gt;     //overdispersion
#&gt;     rep_phi[model_type] ~ exponential(phi_prior);
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:t], rep_phi[model_type]) * weight;
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:t]) * weight;
#&gt;   }
#&gt; }
#&gt; 
#&gt; 
#&gt; real[] R_to_growth(vector R, real gt_mean, real gt_sd) {
#&gt;   real k = pow(gt_sd / gt_mean, 2);
#&gt;   int t = num_elements(R);
#&gt;   real r[t];
#&gt;   for (s in 1:t) {
#&gt;     r[s] = (pow(R[s], k) - 1) / (k * gt_mean);
#&gt;   } 
#&gt;   return(r);
#&gt; }
#&gt; 
#&gt; int[] report_rng(vector reports, real[] rep_phi, int model_type) {
#&gt;   int t = num_elements(reports);
#&gt;   int sampled_reports[t];
#&gt;   if (model_type) {
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;   }else{
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt;   return(sampled_reports);
#&gt; }
#&gt; 
#&gt; 
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt; 
#&gt;   int t;                                            // unobserved time
#&gt;   int seeding_time;                                 // time period used for seeding and not observed
#&gt;   int horizon;                                      // forecast horizon
#&gt;   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;               // median shifted smoothed cases
#&gt; 
#&gt;   int delays;                  // no. of delay distributions
#&gt;   real delay_mean_sd[delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays];       // maximum incubation period
#&gt; 
#&gt;   real L;				                     // boundary value for infections gp
#&gt;   int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt;   real lengthscale_alpha;            // alpha for gp lengthscale prior
#&gt;   real lengthscale_beta;             // beta for gp lengthscale prior
#&gt;   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter
#&gt;   int stationary;                    // is underlying gaussian process first or second order
#&gt;   int fixed;                         //  should a gaussian process be used
#&gt; 
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt; 
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   int bp_n;                          // no of breakpoints (0 = no breakpoints)
#&gt;   int breakpoints[t - seeding_time]; // when do breakpoints occur 
#&gt;   int future_fixed;                  // is underlying future Rt assumed to be fixed
#&gt;   int fixed_from;                    // Reference date for when Rt estimation should be fixed
#&gt; 
#&gt;   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int week_effect;                   // should a day of the week effect be estimated
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   // observations
#&gt;   int ot = t - seeding_time - horizon;  // observed time
#&gt;   int ot_h = ot + horizon;  // observed time + forecast horizon
#&gt;   // gaussian process
#&gt;   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);
#&gt;   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function 
#&gt;   // Rt
#&gt;   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); 
#&gt;   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); 
#&gt; }
#&gt; 
#&gt; parameters{
#&gt;   // gaussian process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];    // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];  // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;             // unconstrained noise
#&gt;   // Rt
#&gt;   vector[estimate_r] log_R;             // baseline reproduction number estimate (log)
#&gt;   vector[estimate_r &gt; 0 ? seeding_time : 0] initial_infections;// seed infections 
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];  // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];   // sd of generation time
#&gt;   real bp_effects[bp_n];                // Rt breakpoint effects
#&gt;   // observation model
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];   // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];     // sd of delays
#&gt;   simplex[week_effect ? 7 : 1] day_of_week_simplex;   // day of week reporting effect 
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];  // overdispersion of the reporting process
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise  generated by the gaussian process
#&gt;   vector[estimate_r &gt; 0 ? ot_h : 0] R;                    // reproduction number
#&gt;   vector[t] infections;                                   // latent infections
#&gt;   vector[ot_h] reports;                                   // observed cases
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta);
#&gt;   }
#&gt;   // Estimate latent infections
#&gt;   if (estimate_r) {
#&gt;     // via Rt
#&gt;     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);
#&gt;     infections = generate_infections(R, seeding_time, gt_mean, gt_sd, max_gt, shifted_cases, initial_infections);
#&gt;   }else{
#&gt;     // via deconvolution
#&gt;     infections = deconvolve_infections(shifted_cases, noise, fixed);
#&gt;   }
#&gt;   // convolve from latent infections to mean of observations
#&gt;   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);
#&gt;  // weekly reporting effect
#&gt;  if (week_effect) {
#&gt;    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);
#&gt;   }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;     gaussian_process_lp(rho, alpha, eta, lengthscale_alpha, lengthscale_beta, alpha_sd);
#&gt;   }
#&gt;   // penalised priors for delay distributions
#&gt;   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);
#&gt;   // Rt priors
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     log_R ~ normal(r_logmean, r_logsd);
#&gt;     //breakpoint effects on Rt
#&gt;     if (bp_n &gt; 0) {
#&gt;       bp_effects ~ normal(0, 0.1);
#&gt;     }
#&gt;     // initial infections
#&gt;     initial_infections ~ lognormal(0, 0.1);
#&gt;     // penalised_prior on generation interval
#&gt;     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);
#&gt;   }
#&gt;   // observed reports from mean of reports
#&gt;   report_lp(cases, reports, rep_phi, 1, model_type, horizon, 1);
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[ot_h]; 
#&gt;   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;
#&gt;   real r[ot_h];
#&gt;   if (estimate_r){
#&gt;     // estimate growth from estimated Rt
#&gt;     r = R_to_growth(R, gt_mean[1], gt_sd[1]);
#&gt;   }else{
#&gt;     // sample generation time
#&gt;     real gt_mean_sample = normal_rng(gt_mean_mean, gt_mean_sd);
#&gt;     real gt_sd_sample = normal_rng(gt_sd_mean, gt_sd_sd);
#&gt;     // calculate Rt using infections and generation time
#&gt;     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_mean_sample, max_gt);
#&gt;     // estimate growth from calculated Rt
#&gt;     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);
#&gt;   }
#&gt;   // simulate reported cases
#&gt;   imputed_reports = report_rng(reports, rep_phi, model_type);
#&gt; } 
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $cores
#&gt; [1] 4
#&gt; 
#&gt; $warmup
#&gt; [1] 500
#&gt; 
#&gt; $chains
#&gt; [1] 4
#&gt; 
#&gt; $control
#&gt; $control$adapt_delta
#&gt; [1] 0.99
#&gt; 
#&gt; $control$max_treedepth
#&gt; [1] 15
#&gt; 
#&gt; 
#&gt; $save_warmup
#&gt; [1] FALSE
#&gt; 
#&gt; $seed
#&gt; [1] 67020432
#&gt; 
#&gt; $iter
#&gt; [1] 750
#&gt; </div><div class='input'>
<span class='co'># approximate settings</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span>method <span class='op'>=</span> <span class='st'>"approximate"</span><span class='op'>)</span> 
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt;= 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt;= 0 ? 1e-5 : beta;
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt; 
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt; 
#&gt; // convolve latent infections to reported (but still unobserved) cases
#&gt; vector convolve_to_report(vector infections, 
#&gt;                           real[] delay_mean, 
#&gt;                           real[] delay_sd,
#&gt;                           int[] max_delay,
#&gt;                           int seeding_time) {
#&gt;   int t = num_elements(infections);
#&gt;   vector[t - seeding_time] reports;
#&gt;   vector[t] reports_hold = infections;
#&gt;   int delays = num_elements(delay_mean);
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;       for (j in 1:(max_delay[s])) {
#&gt;         rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;       }
#&gt;       reports_hold = convolve(reports_hold, rev_delay);
#&gt;     }
#&gt;     reports = reports_hold[(seeding_time + 1):t];
#&gt;   }else{
#&gt;     reports = infections[(seeding_time + 1):t];
#&gt;   }
#&gt;   return(reports);
#&gt; }
#&gt; 
#&gt; void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, 
#&gt;                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){
#&gt;     int delays = num_elements(delay_mean);
#&gt;     if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;
#&gt;     }
#&gt;   }
#&gt; }
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 
#&gt; 
#&gt; int setup_noise(int ot_h, int t, int horizon, int estimate_r, 
#&gt;                 int stationary, int future_fixed, int fixed_from) {
#&gt;   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;
#&gt;   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time; 
#&gt;   return(noise_terms);
#&gt; }
#&gt; 
#&gt; 
#&gt; matrix setup_gp(int M, real L, int dimension) {
#&gt;   vector[dimension] time;
#&gt;   matrix[dimension, M] PHI;
#&gt;   for (s in 1:dimension) {
#&gt;     time[s] = s;
#&gt;   }
#&gt;   for (m in 1:M){ 
#&gt;     PHI[,m] = phi_SE(L, m, time); 
#&gt;   }
#&gt;   return(PHI);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector update_gp(matrix PHI, int M, real L, real alpha, real rho, vector eta) {
#&gt;   vector[M] diagSPD;    // spectral density
#&gt;   vector[M] SPD_eta;    // spectral density * noise
#&gt;   int noise_terms = rows(PHI);
#&gt;   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);
#&gt;   // GP in noise - spectral densities
#&gt;   for(m in 1:M){ 
#&gt;     diagSPD[m] =  sqrt(spd_SE(alpha, rho, sqrt(lambda(L, m)))); 
#&gt;   }
#&gt;   SPD_eta = diagSPD .* eta;
#&gt;   noise = noise + PHI[,] * SPD_eta;
#&gt;   return(noise);
#&gt; }
#&gt; 
#&gt; void gaussian_process_lp(real[] rho, real[] alpha, vector eta,
#&gt;                          real ls_alpha, real ls_beta, real alpha_sd) {
#&gt;   rho ~ inv_gamma(ls_alpha, ls_beta);
#&gt;   alpha ~ normal(0, alpha_sd);
#&gt;   eta ~ std_normal();
#&gt; }
#&gt; 
#&gt; 
#&gt; 
#&gt; real update_breakpoints(real input_R, real[] bp_effects,
#&gt;                         int bp_index, int at_bp,
#&gt;                         int stationary) {
#&gt;   real R = input_R;
#&gt;   if (stationary) {
#&gt;     if (bp_index &gt; 0) {
#&gt;       R += sum(bp_effects[1:bp_index]);
#&gt;       }
#&gt;   }else{
#&gt;     if (at_bp) {
#&gt;       R += bp_effects[bp_index];
#&gt;     }
#&gt;   }               
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; real update_R(vector R, vector noise, int noise_terms,
#&gt;               int index, int stationary) {
#&gt;   real cR = R[index];
#&gt;   if (noise_terms &gt; 0) {
#&gt;     if (stationary){
#&gt;       if (index &lt;= noise_terms) {
#&gt;         cR += noise[index];
#&gt;       }else{
#&gt;         if (index &gt; 1) {
#&gt;            cR = R[index - 1];
#&gt;         }
#&gt;       }
#&gt;     }else{
#&gt;       if (index &lt;= (noise_terms + 1)) {
#&gt;         cR = R[index - 1] + noise[index - 1];
#&gt;       }else{
#&gt;         cR = R[index - 1];
#&gt;       }
#&gt;     }
#&gt;   }
#&gt;   return(cR);
#&gt; }
#&gt; 
#&gt; vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,
#&gt;                  real[] bp_effects, int stationary) {
#&gt;   // define control parameters
#&gt;   int noise_terms = num_elements(noise);
#&gt;   int i_stationary = noise_terms &gt; 0 ? stationary : 1;
#&gt;   int t = num_elements(input_R);
#&gt;   int bp_n = num_elements(bp_effects);
#&gt;   int bp_in = 0;
#&gt;   int at_bp = 0;
#&gt;   int index;
#&gt;   vector[t] R;
#&gt;   // initialise Rt
#&gt;   if (i_stationary) {
#&gt;     R = rep_vector(log_R, t);
#&gt;     index = 1;
#&gt;   }else{
#&gt;     R[1] = log_R;
#&gt;     index = 2;
#&gt;   }
#&gt;   // iteratively update Rt
#&gt;   for (s in index:t) {
#&gt;     R[s] = update_R(R, noise, noise_terms, s, i_stationary);
#&gt;     if (bp_n &gt; 0) {
#&gt;       at_bp = bps[s];
#&gt;       bp_in += at_bp;
#&gt;       R[s] = update_breakpoints(R[s], bp_effects, bp_in, at_bp, i_stationary);
#&gt;     }
#&gt;   }
#&gt;   // convert to correct scale
#&gt;   R = exp(R);
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; real update_infectiousness(vector infections, vector gt_pmf,
#&gt;                            int seeding_time, int max_gt, int index){
#&gt;   int inf_start = max(1, (index + seeding_time - max_gt));
#&gt;   int inf_end = (index + seeding_time - 1);
#&gt;   int pmf_accessed = min(max_gt, index + seeding_time - 1);
#&gt;   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));
#&gt;   return(new_inf);
#&gt; }
#&gt; 
#&gt; vector generate_infections(vector R, int seeding_time, real[] gt_mean, 
#&gt;                            real[] gt_sd, int max_gt, vector shifted_cases,
#&gt;                            vector initial_infections) {
#&gt;   int rt = num_elements(R);
#&gt;   int t = rt + seeding_time;
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   vector[max_gt] gt_pmf;              // reversed generation time pdf
#&gt;   vector[rt] infectiousness = rep_vector(1e-5, rt);  // infections over time
#&gt;   
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] = discretised_gamma_pmf(max_gt - j + 1, gt_mean[1], gt_sd[1], max_gt);
#&gt;   }
#&gt;   // estimate initial infections not using Rt
#&gt;   infections[1:seeding_time] = infections[1:seeding_time] + shifted_cases[1:seeding_time] .* initial_infections;
#&gt;   
#&gt;   for (s in 1:rt) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     infections[s + seeding_time] += R[s] * infectiousness[s];
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector deconvolve_infections(vector shifted_cases, vector noise, int fixed) {
#&gt;   int t = num_elements(shifted_cases);
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   if(!fixed) {
#&gt;     infections = infections + shifted_cases .* exp(noise);
#&gt;   }else{
#&gt;     infections = infections + shifted_cases;
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, 
#&gt;                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {
#&gt;     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;
#&gt;     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;
#&gt; }
#&gt; 
#&gt; vector calculate_Rt(vector infections, int seeding_time,
#&gt;                     real gt_mean, real gt_sd, int max_gt) {
#&gt;   vector[max_gt] gt_pmf;  
#&gt;   int t = num_elements(infections);
#&gt;   int ot = t - seeding_time;
#&gt;   vector[ot] R;
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot); 
#&gt;   // calculate PMF of the generation time
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] =  discretised_gamma_pmf(max_gt - j + 1, gt_mean, gt_sd, max_gt);
#&gt;   }
#&gt;   // calculate Rt using Cori et al. approach
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     R[s] = infections[s + seeding_time] / infectiousness[s];
#&gt;   }
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {
#&gt;   int t = num_elements(reports);
#&gt;   // scale day of week effect
#&gt;   vector[7] scaled_effect = 7 * effect;
#&gt;   vector[t] scaled_reports;
#&gt;   for (s in 1:t) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];
#&gt;    }
#&gt;   return(scaled_reports);
#&gt; }
#&gt; 
#&gt;    
#&gt; void report_lp(int[] cases, vector reports, 
#&gt;                real[] rep_phi, int phi_prior,
#&gt;                int model_type, int horizon,
#&gt;                int weight) {
#&gt;   int t = num_elements(reports) - horizon;
#&gt;   if (model_type) {
#&gt;     //overdispersion
#&gt;     rep_phi[model_type] ~ exponential(phi_prior);
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:t], rep_phi[model_type]) * weight;
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:t]) * weight;
#&gt;   }
#&gt; }
#&gt; 
#&gt; 
#&gt; real[] R_to_growth(vector R, real gt_mean, real gt_sd) {
#&gt;   real k = pow(gt_sd / gt_mean, 2);
#&gt;   int t = num_elements(R);
#&gt;   real r[t];
#&gt;   for (s in 1:t) {
#&gt;     r[s] = (pow(R[s], k) - 1) / (k * gt_mean);
#&gt;   } 
#&gt;   return(r);
#&gt; }
#&gt; 
#&gt; int[] report_rng(vector reports, real[] rep_phi, int model_type) {
#&gt;   int t = num_elements(reports);
#&gt;   int sampled_reports[t];
#&gt;   if (model_type) {
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;   }else{
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt;   return(sampled_reports);
#&gt; }
#&gt; 
#&gt; 
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt; 
#&gt;   int t;                                            // unobserved time
#&gt;   int seeding_time;                                 // time period used for seeding and not observed
#&gt;   int horizon;                                      // forecast horizon
#&gt;   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;               // median shifted smoothed cases
#&gt; 
#&gt;   int delays;                  // no. of delay distributions
#&gt;   real delay_mean_sd[delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays];       // maximum incubation period
#&gt; 
#&gt;   real L;				                     // boundary value for infections gp
#&gt;   int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt;   real lengthscale_alpha;            // alpha for gp lengthscale prior
#&gt;   real lengthscale_beta;             // beta for gp lengthscale prior
#&gt;   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter
#&gt;   int stationary;                    // is underlying gaussian process first or second order
#&gt;   int fixed;                         //  should a gaussian process be used
#&gt; 
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt; 
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   int bp_n;                          // no of breakpoints (0 = no breakpoints)
#&gt;   int breakpoints[t - seeding_time]; // when do breakpoints occur 
#&gt;   int future_fixed;                  // is underlying future Rt assumed to be fixed
#&gt;   int fixed_from;                    // Reference date for when Rt estimation should be fixed
#&gt; 
#&gt;   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int week_effect;                   // should a day of the week effect be estimated
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   // observations
#&gt;   int ot = t - seeding_time - horizon;  // observed time
#&gt;   int ot_h = ot + horizon;  // observed time + forecast horizon
#&gt;   // gaussian process
#&gt;   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);
#&gt;   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function 
#&gt;   // Rt
#&gt;   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); 
#&gt;   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); 
#&gt; }
#&gt; 
#&gt; parameters{
#&gt;   // gaussian process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];    // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];  // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;             // unconstrained noise
#&gt;   // Rt
#&gt;   vector[estimate_r] log_R;             // baseline reproduction number estimate (log)
#&gt;   vector[estimate_r &gt; 0 ? seeding_time : 0] initial_infections;// seed infections 
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];  // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];   // sd of generation time
#&gt;   real bp_effects[bp_n];                // Rt breakpoint effects
#&gt;   // observation model
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];   // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];     // sd of delays
#&gt;   simplex[week_effect ? 7 : 1] day_of_week_simplex;   // day of week reporting effect 
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];  // overdispersion of the reporting process
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise  generated by the gaussian process
#&gt;   vector[estimate_r &gt; 0 ? ot_h : 0] R;                    // reproduction number
#&gt;   vector[t] infections;                                   // latent infections
#&gt;   vector[ot_h] reports;                                   // observed cases
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta);
#&gt;   }
#&gt;   // Estimate latent infections
#&gt;   if (estimate_r) {
#&gt;     // via Rt
#&gt;     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);
#&gt;     infections = generate_infections(R, seeding_time, gt_mean, gt_sd, max_gt, shifted_cases, initial_infections);
#&gt;   }else{
#&gt;     // via deconvolution
#&gt;     infections = deconvolve_infections(shifted_cases, noise, fixed);
#&gt;   }
#&gt;   // convolve from latent infections to mean of observations
#&gt;   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);
#&gt;  // weekly reporting effect
#&gt;  if (week_effect) {
#&gt;    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);
#&gt;   }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;     gaussian_process_lp(rho, alpha, eta, lengthscale_alpha, lengthscale_beta, alpha_sd);
#&gt;   }
#&gt;   // penalised priors for delay distributions
#&gt;   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);
#&gt;   // Rt priors
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     log_R ~ normal(r_logmean, r_logsd);
#&gt;     //breakpoint effects on Rt
#&gt;     if (bp_n &gt; 0) {
#&gt;       bp_effects ~ normal(0, 0.1);
#&gt;     }
#&gt;     // initial infections
#&gt;     initial_infections ~ lognormal(0, 0.1);
#&gt;     // penalised_prior on generation interval
#&gt;     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);
#&gt;   }
#&gt;   // observed reports from mean of reports
#&gt;   report_lp(cases, reports, rep_phi, 1, model_type, horizon, 1);
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[ot_h]; 
#&gt;   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;
#&gt;   real r[ot_h];
#&gt;   if (estimate_r){
#&gt;     // estimate growth from estimated Rt
#&gt;     r = R_to_growth(R, gt_mean[1], gt_sd[1]);
#&gt;   }else{
#&gt;     // sample generation time
#&gt;     real gt_mean_sample = normal_rng(gt_mean_mean, gt_mean_sd);
#&gt;     real gt_sd_sample = normal_rng(gt_sd_mean, gt_sd_sd);
#&gt;     // calculate Rt using infections and generation time
#&gt;     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_mean_sample, max_gt);
#&gt;     // estimate growth from calculated Rt
#&gt;     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);
#&gt;   }
#&gt;   // simulate reported cases
#&gt;   imputed_reports = report_rng(reports, rep_phi, model_type);
#&gt; } 
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $trials
#&gt; [1] 10
#&gt; 
#&gt; $iter
#&gt; [1] 10000
#&gt; 
#&gt; $output_samples
#&gt; [1] 1000
#&gt; </div><div class='input'><span class='co'># increasing warmup</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span>stan_args <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>warmup <span class='op'>=</span> <span class='fl'>1000</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt;= 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt;= 0 ? 1e-5 : beta;
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt; 
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt; 
#&gt; // convolve latent infections to reported (but still unobserved) cases
#&gt; vector convolve_to_report(vector infections, 
#&gt;                           real[] delay_mean, 
#&gt;                           real[] delay_sd,
#&gt;                           int[] max_delay,
#&gt;                           int seeding_time) {
#&gt;   int t = num_elements(infections);
#&gt;   vector[t - seeding_time] reports;
#&gt;   vector[t] reports_hold = infections;
#&gt;   int delays = num_elements(delay_mean);
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;       for (j in 1:(max_delay[s])) {
#&gt;         rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;       }
#&gt;       reports_hold = convolve(reports_hold, rev_delay);
#&gt;     }
#&gt;     reports = reports_hold[(seeding_time + 1):t];
#&gt;   }else{
#&gt;     reports = infections[(seeding_time + 1):t];
#&gt;   }
#&gt;   return(reports);
#&gt; }
#&gt; 
#&gt; void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, 
#&gt;                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){
#&gt;     int delays = num_elements(delay_mean);
#&gt;     if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;
#&gt;     }
#&gt;   }
#&gt; }
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 
#&gt; 
#&gt; int setup_noise(int ot_h, int t, int horizon, int estimate_r, 
#&gt;                 int stationary, int future_fixed, int fixed_from) {
#&gt;   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;
#&gt;   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time; 
#&gt;   return(noise_terms);
#&gt; }
#&gt; 
#&gt; 
#&gt; matrix setup_gp(int M, real L, int dimension) {
#&gt;   vector[dimension] time;
#&gt;   matrix[dimension, M] PHI;
#&gt;   for (s in 1:dimension) {
#&gt;     time[s] = s;
#&gt;   }
#&gt;   for (m in 1:M){ 
#&gt;     PHI[,m] = phi_SE(L, m, time); 
#&gt;   }
#&gt;   return(PHI);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector update_gp(matrix PHI, int M, real L, real alpha, real rho, vector eta) {
#&gt;   vector[M] diagSPD;    // spectral density
#&gt;   vector[M] SPD_eta;    // spectral density * noise
#&gt;   int noise_terms = rows(PHI);
#&gt;   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);
#&gt;   // GP in noise - spectral densities
#&gt;   for(m in 1:M){ 
#&gt;     diagSPD[m] =  sqrt(spd_SE(alpha, rho, sqrt(lambda(L, m)))); 
#&gt;   }
#&gt;   SPD_eta = diagSPD .* eta;
#&gt;   noise = noise + PHI[,] * SPD_eta;
#&gt;   return(noise);
#&gt; }
#&gt; 
#&gt; void gaussian_process_lp(real[] rho, real[] alpha, vector eta,
#&gt;                          real ls_alpha, real ls_beta, real alpha_sd) {
#&gt;   rho ~ inv_gamma(ls_alpha, ls_beta);
#&gt;   alpha ~ normal(0, alpha_sd);
#&gt;   eta ~ std_normal();
#&gt; }
#&gt; 
#&gt; 
#&gt; 
#&gt; real update_breakpoints(real input_R, real[] bp_effects,
#&gt;                         int bp_index, int at_bp,
#&gt;                         int stationary) {
#&gt;   real R = input_R;
#&gt;   if (stationary) {
#&gt;     if (bp_index &gt; 0) {
#&gt;       R += sum(bp_effects[1:bp_index]);
#&gt;       }
#&gt;   }else{
#&gt;     if (at_bp) {
#&gt;       R += bp_effects[bp_index];
#&gt;     }
#&gt;   }               
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; real update_R(vector R, vector noise, int noise_terms,
#&gt;               int index, int stationary) {
#&gt;   real cR = R[index];
#&gt;   if (noise_terms &gt; 0) {
#&gt;     if (stationary){
#&gt;       if (index &lt;= noise_terms) {
#&gt;         cR += noise[index];
#&gt;       }else{
#&gt;         if (index &gt; 1) {
#&gt;            cR = R[index - 1];
#&gt;         }
#&gt;       }
#&gt;     }else{
#&gt;       if (index &lt;= (noise_terms + 1)) {
#&gt;         cR = R[index - 1] + noise[index - 1];
#&gt;       }else{
#&gt;         cR = R[index - 1];
#&gt;       }
#&gt;     }
#&gt;   }
#&gt;   return(cR);
#&gt; }
#&gt; 
#&gt; vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,
#&gt;                  real[] bp_effects, int stationary) {
#&gt;   // define control parameters
#&gt;   int noise_terms = num_elements(noise);
#&gt;   int i_stationary = noise_terms &gt; 0 ? stationary : 1;
#&gt;   int t = num_elements(input_R);
#&gt;   int bp_n = num_elements(bp_effects);
#&gt;   int bp_in = 0;
#&gt;   int at_bp = 0;
#&gt;   int index;
#&gt;   vector[t] R;
#&gt;   // initialise Rt
#&gt;   if (i_stationary) {
#&gt;     R = rep_vector(log_R, t);
#&gt;     index = 1;
#&gt;   }else{
#&gt;     R[1] = log_R;
#&gt;     index = 2;
#&gt;   }
#&gt;   // iteratively update Rt
#&gt;   for (s in index:t) {
#&gt;     R[s] = update_R(R, noise, noise_terms, s, i_stationary);
#&gt;     if (bp_n &gt; 0) {
#&gt;       at_bp = bps[s];
#&gt;       bp_in += at_bp;
#&gt;       R[s] = update_breakpoints(R[s], bp_effects, bp_in, at_bp, i_stationary);
#&gt;     }
#&gt;   }
#&gt;   // convert to correct scale
#&gt;   R = exp(R);
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; real update_infectiousness(vector infections, vector gt_pmf,
#&gt;                            int seeding_time, int max_gt, int index){
#&gt;   int inf_start = max(1, (index + seeding_time - max_gt));
#&gt;   int inf_end = (index + seeding_time - 1);
#&gt;   int pmf_accessed = min(max_gt, index + seeding_time - 1);
#&gt;   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));
#&gt;   return(new_inf);
#&gt; }
#&gt; 
#&gt; vector generate_infections(vector R, int seeding_time, real[] gt_mean, 
#&gt;                            real[] gt_sd, int max_gt, vector shifted_cases,
#&gt;                            vector initial_infections) {
#&gt;   int rt = num_elements(R);
#&gt;   int t = rt + seeding_time;
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   vector[max_gt] gt_pmf;              // reversed generation time pdf
#&gt;   vector[rt] infectiousness = rep_vector(1e-5, rt);  // infections over time
#&gt;   
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] = discretised_gamma_pmf(max_gt - j + 1, gt_mean[1], gt_sd[1], max_gt);
#&gt;   }
#&gt;   // estimate initial infections not using Rt
#&gt;   infections[1:seeding_time] = infections[1:seeding_time] + shifted_cases[1:seeding_time] .* initial_infections;
#&gt;   
#&gt;   for (s in 1:rt) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     infections[s + seeding_time] += R[s] * infectiousness[s];
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector deconvolve_infections(vector shifted_cases, vector noise, int fixed) {
#&gt;   int t = num_elements(shifted_cases);
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   if(!fixed) {
#&gt;     infections = infections + shifted_cases .* exp(noise);
#&gt;   }else{
#&gt;     infections = infections + shifted_cases;
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; 
#&gt; void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, 
#&gt;                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {
#&gt;     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;
#&gt;     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;
#&gt; }
#&gt; 
#&gt; vector calculate_Rt(vector infections, int seeding_time,
#&gt;                     real gt_mean, real gt_sd, int max_gt) {
#&gt;   vector[max_gt] gt_pmf;  
#&gt;   int t = num_elements(infections);
#&gt;   int ot = t - seeding_time;
#&gt;   vector[ot] R;
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot); 
#&gt;   // calculate PMF of the generation time
#&gt;   for (j in 1:(max_gt)) {
#&gt;     gt_pmf[j] =  discretised_gamma_pmf(max_gt - j + 1, gt_mean, gt_sd, max_gt);
#&gt;   }
#&gt;   // calculate Rt using Cori et al. approach
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     R[s] = infections[s + seeding_time] / infectiousness[s];
#&gt;   }
#&gt;   return(R);
#&gt; }
#&gt; 
#&gt; 
#&gt; vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {
#&gt;   int t = num_elements(reports);
#&gt;   // scale day of week effect
#&gt;   vector[7] scaled_effect = 7 * effect;
#&gt;   vector[t] scaled_reports;
#&gt;   for (s in 1:t) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];
#&gt;    }
#&gt;   return(scaled_reports);
#&gt; }
#&gt; 
#&gt;    
#&gt; void report_lp(int[] cases, vector reports, 
#&gt;                real[] rep_phi, int phi_prior,
#&gt;                int model_type, int horizon,
#&gt;                int weight) {
#&gt;   int t = num_elements(reports) - horizon;
#&gt;   if (model_type) {
#&gt;     //overdispersion
#&gt;     rep_phi[model_type] ~ exponential(phi_prior);
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:t], rep_phi[model_type]) * weight;
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:t]) * weight;
#&gt;   }
#&gt; }
#&gt; 
#&gt; 
#&gt; real[] R_to_growth(vector R, real gt_mean, real gt_sd) {
#&gt;   real k = pow(gt_sd / gt_mean, 2);
#&gt;   int t = num_elements(R);
#&gt;   real r[t];
#&gt;   for (s in 1:t) {
#&gt;     r[s] = (pow(R[s], k) - 1) / (k * gt_mean);
#&gt;   } 
#&gt;   return(r);
#&gt; }
#&gt; 
#&gt; int[] report_rng(vector reports, real[] rep_phi, int model_type) {
#&gt;   int t = num_elements(reports);
#&gt;   int sampled_reports[t];
#&gt;   if (model_type) {
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;   }else{
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt;   return(sampled_reports);
#&gt; }
#&gt; 
#&gt; 
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt; 
#&gt;   int t;                                            // unobserved time
#&gt;   int seeding_time;                                 // time period used for seeding and not observed
#&gt;   int horizon;                                      // forecast horizon
#&gt;   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;               // median shifted smoothed cases
#&gt; 
#&gt;   int delays;                  // no. of delay distributions
#&gt;   real delay_mean_sd[delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays];       // maximum incubation period
#&gt; 
#&gt;   real L;				                     // boundary value for infections gp
#&gt;   int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt;   real lengthscale_alpha;            // alpha for gp lengthscale prior
#&gt;   real lengthscale_beta;             // beta for gp lengthscale prior
#&gt;   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter
#&gt;   int stationary;                    // is underlying gaussian process first or second order
#&gt;   int fixed;                         //  should a gaussian process be used
#&gt; 
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt; 
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   int bp_n;                          // no of breakpoints (0 = no breakpoints)
#&gt;   int breakpoints[t - seeding_time]; // when do breakpoints occur 
#&gt;   int future_fixed;                  // is underlying future Rt assumed to be fixed
#&gt;   int fixed_from;                    // Reference date for when Rt estimation should be fixed
#&gt; 
#&gt;   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int week_effect;                   // should a day of the week effect be estimated
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   // observations
#&gt;   int ot = t - seeding_time - horizon;  // observed time
#&gt;   int ot_h = ot + horizon;  // observed time + forecast horizon
#&gt;   // gaussian process
#&gt;   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);
#&gt;   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function 
#&gt;   // Rt
#&gt;   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); 
#&gt;   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); 
#&gt; }
#&gt; 
#&gt; parameters{
#&gt;   // gaussian process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];    // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];  // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;             // unconstrained noise
#&gt;   // Rt
#&gt;   vector[estimate_r] log_R;             // baseline reproduction number estimate (log)
#&gt;   vector[estimate_r &gt; 0 ? seeding_time : 0] initial_infections;// seed infections 
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];  // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];   // sd of generation time
#&gt;   real bp_effects[bp_n];                // Rt breakpoint effects
#&gt;   // observation model
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];   // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];     // sd of delays
#&gt;   simplex[week_effect ? 7 : 1] day_of_week_simplex;   // day of week reporting effect 
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];  // overdispersion of the reporting process
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise  generated by the gaussian process
#&gt;   vector[estimate_r &gt; 0 ? ot_h : 0] R;                    // reproduction number
#&gt;   vector[t] infections;                                   // latent infections
#&gt;   vector[ot_h] reports;                                   // observed cases
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta);
#&gt;   }
#&gt;   // Estimate latent infections
#&gt;   if (estimate_r) {
#&gt;     // via Rt
#&gt;     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);
#&gt;     infections = generate_infections(R, seeding_time, gt_mean, gt_sd, max_gt, shifted_cases, initial_infections);
#&gt;   }else{
#&gt;     // via deconvolution
#&gt;     infections = deconvolve_infections(shifted_cases, noise, fixed);
#&gt;   }
#&gt;   // convolve from latent infections to mean of observations
#&gt;   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);
#&gt;  // weekly reporting effect
#&gt;  if (week_effect) {
#&gt;    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);
#&gt;   }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;     gaussian_process_lp(rho, alpha, eta, lengthscale_alpha, lengthscale_beta, alpha_sd);
#&gt;   }
#&gt;   // penalised priors for delay distributions
#&gt;   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);
#&gt;   // Rt priors
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     log_R ~ normal(r_logmean, r_logsd);
#&gt;     //breakpoint effects on Rt
#&gt;     if (bp_n &gt; 0) {
#&gt;       bp_effects ~ normal(0, 0.1);
#&gt;     }
#&gt;     // initial infections
#&gt;     initial_infections ~ lognormal(0, 0.1);
#&gt;     // penalised_prior on generation interval
#&gt;     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);
#&gt;   }
#&gt;   // observed reports from mean of reports
#&gt;   report_lp(cases, reports, rep_phi, 1, model_type, horizon, 1);
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[ot_h]; 
#&gt;   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;
#&gt;   real r[ot_h];
#&gt;   if (estimate_r){
#&gt;     // estimate growth from estimated Rt
#&gt;     r = R_to_growth(R, gt_mean[1], gt_sd[1]);
#&gt;   }else{
#&gt;     // sample generation time
#&gt;     real gt_mean_sample = normal_rng(gt_mean_mean, gt_mean_sd);
#&gt;     real gt_sd_sample = normal_rng(gt_sd_mean, gt_sd_sd);
#&gt;     // calculate Rt using infections and generation time
#&gt;     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_mean_sample, max_gt);
#&gt;     // estimate growth from calculated Rt
#&gt;     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);
#&gt;   }
#&gt;   // simulate reported cases
#&gt;   imputed_reports = report_rng(reports, rep_phi, model_type);
#&gt; } 
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $cores
#&gt; [1] 4
#&gt; 
#&gt; $chains
#&gt; [1] 4
#&gt; 
#&gt; $control
#&gt; $control$adapt_delta
#&gt; [1] 0.99
#&gt; 
#&gt; $control$max_treedepth
#&gt; [1] 15
#&gt; 
#&gt; 
#&gt; $save_warmup
#&gt; [1] FALSE
#&gt; 
#&gt; $seed
#&gt; [1] 15814683
#&gt; 
#&gt; $warmup
#&gt; [1] 1000
#&gt; 
#&gt; $iter
#&gt; [1] 1250
#&gt; </div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by <a href='https://www.samabbott.co.uk/'>Sam Abbott</a>, Joel Hellewell, Robin Thompson, Katelyn Gostic, Katharine Sherratt, Sophie Meakin, James Munday, Nikos Bosse, Joe Hickson, EpiForecasts, <a href='https://www.lshtm.ac.uk/aboutus/people/funk.sebastian'>Sebastian Funk</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
   </div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script>
<script>
  docsearch({
    
    
    apiKey: '43da981922253a06c4dfab7b53f2410e',
    indexName: 'epinow2',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>



  </body>
</html>


